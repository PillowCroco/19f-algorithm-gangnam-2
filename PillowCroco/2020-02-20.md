## 2020.2.20 (목), 문자열 처리
- [x] https://leetcode.com/problems/longest-substring-without-repeating-characters/
- [ ] [https://leetcode.com/problems/valid-parenthesis-string/](https://leetcode.com/problems/valid-parenthesis-string/)
- [ ] [https://leetcode.com/problems/print-words-vertically/](https://leetcode.com/problems/print-words-vertically/)
- [ ] [https://www.acmicpc.net/problem/2800](https://www.acmicpc.net/problem/2800)
- [ ] [https://leetcode.com/problems/delete-operation-for-two-strings/](https://leetcode.com/problems/delete-operation-for-two-strings/)
- [ ] [https://leetcode.com/problems/edit-distance/](https://leetcode.com/problems/edit-distance/)
 - [ ] [https://leetcode.com/problems/break-a-palindrome/](https://leetcode.com/problems/break-a-palindrome/) (Palindrome, 회문에 대한 문제가 많기에)

 ---

 ### Longest Substring Without Repeating Characters
 처음 접근은, 다음 방식으로 했다.

```
dp와 set으로 가능
set하나 초기화 ss
substring list인 t 초기화
:t의 i번째에는 s의 i번째로 끝나는 가장 긴 substring이 저장됨
t[0]= s[0]
ss에 s0넣기

1번째에는 s1이 ss에있나 체크
없으면 t1은 t0+s1
있으면 t1은 s1

2번째에는 s2가 ss에 있나 체크
없으면 t2는 t1+s2
있으면 t2는 s2
...
```
그랬더니 다음과 같은 반례가 등장했다.

```
'dvdf'의 경우 답이 3인데, 2라고 return한다.
```
아! 역방향을 생각하지 않았구나! 라고 생각해서, 역방향을 저장하는`rs, rss, rt` 를 만들었다. 그 결과는 다음과 같다.

```
"asjrgapa"의 경우 답이 6인데, 5라고 return한다.
`sjrgap` 가 해당 substring인데, 이것이 해결되지 않았다.
```
뭔가 만들면서 께름칙한 부분이 있었는데, 바로 이거였다! 시작점이든 끝점이든, 둘 중 하나가 고정이 되면 안된다. 유동적으로 움직일 수 있어야한다. 따라서, 역방향은 생각할 필요도 없었다. 이러한 방향의 해결안이 바로 ***sliding window*** 이다. **substring과 관련된 문제는 *sliding window* 문제로부터 파생된다.** 시간이 나면, 이와 관련된 다음 다른 문제를 풀어보자.

> [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)  
> [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)  

 - Time Complexity : O(n), `n = len(s)`
```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        # create a window with left and right
        # keep a hash of elements already added
        left = 0
        right = 0
        seen = {} # hashmap, substring에 있는 char가 s의 어느 idx에 있는지 저장.

        max_count = 0

        for i, character in enumerate(s):

            # 중복되지 않은 경우, hashmap에 추가하고 오른쪽 창문을 밂.
            # or 뒤는 이미 substring에서 제외되어있는 경우를 뜻함
            # (여전히 중복되지 않은 경우임)
            if character not in seen or seen[character] < left:
                seen[character] = i
                right = i

                # 밀었는데, 기존의 가장 긴 substring보다 길면 길이 update.
                if (right - left + 1) > max_count:
                    max_count = (right - left + 1)

            # 중복된 경우, 새로 추가된 것을 포함시키고
            # 기존의 것(왼쪽에 있는 것)을 날려버린다.
            # 즉 left를 중복된 것 중 왼쪽 것의 바로 오른쪽으로 당긴다.
            else:

                # update index of last time we saw the character
                left = seen[character] + 1
                seen[character] = i 
        return max_count
```
